<!DOCTYPE html>
<html lang="en">
<head>
    <style>
  #btc-donation-bar {
    background: #222;
    color: #eee;
    font-family: monospace;
    text-align: center;
    padding: 10px;
    font-size: 16px;
    position: fixed;
    top: 0;
    width: 100%;
    z-index: 9999;
    user-select: all;
  }
  #content-padding {
    height: 40px; /* same height as the bar */
  }
</style>

<div id="btc-donation-bar">
  Support the game with Bitcoin donations: <code>bc1qk4r2kdev7t8qvfrsa767g7h63mj4526n0skkxm</code>
</div>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nick's Yookay Crossing</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            font-family: 'Courier New', monospace;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-header h1 {
            color: #e74c3c;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin: 0;
            font-size: 2.5em;
        }

        .damage-key {
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e74c3c;
            margin-bottom: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 800px;
        }

        .damage-item {
            text-align: center;
            padding: 8px;
            border-radius: 5px;
        }

        .damage-high { background: rgba(231, 76, 60, 0.3); }
        .damage-med { background: rgba(230, 126, 34, 0.3); }
        .damage-low { background: rgba(39, 174, 96, 0.3); }
        .damage-heal { background: rgba(52, 152, 219, 0.3); }

        .game-info {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: bold;
        }

        .score, .level, .hp {
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #3498db;
        }

        .hp {
            color: #27ae60;
        }

        .hp.low {
            color: #e74c3c;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .game-container {
            background: #34495e;
            border: 4px solid #2c3e50;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #gameCanvas {
            background: #2c3e50;
            border: 2px solid #95a5a6;
            border-radius: 8px;
            display: block;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #3498db;
        }

        .controls h3 {
            margin-top: 0;
            color: #3498db;
        }

        .street-info {
            margin: 20px 0;
            text-align: center;
            background: rgba(231, 76, 60, 0.2);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #e74c3c;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            border: 3px solid #e74c3c;
            display: none;
        }

        .restart-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
        }

        .restart-btn:hover {
            background: #2980b9;
        }

        .level-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            border: 3px solid #27ae60;
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø NICK'S YOOKAY CROSSING üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø</h1>
        <p>Nick, 30, navigating the chaotic streets of the Yookay to get to work!</p>
    </div>

    <div class="damage-key">
        <div class="damage-item damage-high">üî™ KNIVES: -30 HP<br/>LETHAL!</div>
        <div class="damage-item damage-med">üö¥‚Äç‚ôÇÔ∏èüõµ DELIVERY: -20 HP<br/>DANGEROUS!</div>
        <div class="damage-item damage-low">üö≤ CYCLISTS: -10 HP<br/>ANNOYING!</div>
        <div class="damage-item damage-med">üöóüöå VEHICLES: -25 HP<br/>PAINFUL!</div>
        <div class="damage-item damage-heal">üçüü•™ FOOD: +15 HP<br/>TASTY!</div>
        <div class="damage-item damage-heal">üèùÔ∏è ISLANDS: SAFE ZONES<br/>REFUGE!</div>
    </div>

    <div class="game-info">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="level">Street: <span id="level">1</span>/8</div>
        <div class="hp" id="hpDisplay">HP: <span id="hp">100</span>/100</div>
    </div>

    <div class="street-info">
        <strong id="streetName">Oxford Street</strong> - Mind the traffic islands and grab some food!
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="900" height="700"></canvas>
    </div>

    <div class="controls">
        <h3>Controls</h3>
        <p>üî¥ Use ARROW KEYS to move Nick safely across 8 streets of Yookay chaos</p>
        <p>üî¥ Use traffic islands as safe zones ‚Ä¢ Grab food to heal ‚Ä¢ Avoid all the madness!</p>
    </div>

    <div class="game-over" id="gameOver">
        <h2>Nick Didn't Make It!</h2>
        <p id="gameOverMessage">The streets of the Yookay claimed another victim...</p>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="restart-btn" onclick="restartGame()">Try Again</button>
    </div>

    <div class="level-complete" id="levelComplete">
        <h2>Street Crossed!</h2>
        <p>Nick made it across another Yookay street!</p>
        <p>Bonus: <span id="levelBonus">0</span> points</p>
        <button class="restart-btn" onclick="nextStreet()">Next Street</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = {
            score: 0,
            level: 1,
            hp: 100,
            maxHp: 100,
            gameOver: false,
            paused: false,
            currentStreet: 0
        };

        // Yookay streets - 8 different London streets
        const streets = [
            "Oxford Street",
            "Camden High Street", 
            "Brick Lane",
            "King's Road",
            "Portobello Road",
            "Shoreditch High Street",
            "Borough Market Road",
            "Carnaby Street"
        ];

        // Player object (Nick, 30)
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            width: 30,
            height: 30,
            speed: 4,
            invulnerable: 0
        };

        // Traffic islands
        let trafficIslands = [];

        // Obstacles and items
        let obstacles = [];
        let items = [];

        // Object types with damage/healing values
        const objectTypes = {
            // Hostile - different damage levels
            knife: { symbol: 'üî™', color: '#8b0000', width: 20, height: 20, speed: 2, damage: 30, hostile: true },
            deliveroo: { symbol: 'üö¥‚Äç‚ôÇÔ∏è', color: '#00ccbc', width: 40, height: 25, speed: 3.5, damage: 20, hostile: true },
            ubereats: { symbol: 'üõµ', color: '#000000', width: 45, height: 25, speed: 4, damage: 20, hostile: true },
            cyclist: { symbol: 'üö≤', color: '#27ae60', width: 35, height: 25, speed: 2.5, damage: 10, hostile: true },
            car: { symbol: 'üöó', color: '#f39c12', width: 50, height: 30, speed: 5, damage: 25, hostile: true },
            bus: { symbol: 'üöå', color: '#e74c3c', width: 80, height: 35, speed: 2, damage: 25, hostile: true },
            
            // Friendly - healing items
            chips: { symbol: 'üçü', color: '#f1c40f', width: 25, height: 25, speed: 1, heal: 15, friendly: true },
            sandwich: { symbol: 'ü•™', color: '#e67e22', width: 25, height: 25, speed: 1, heal: 15, friendly: true },
            tea: { symbol: '‚òï', color: '#8b4513', width: 25, height: 25, speed: 1, heal: 10, friendly: true }
        };

        // Initialize traffic islands - they move between levels
        function createTrafficIslands() {
            trafficIslands = [];
            const numIslands = 2 + Math.floor(gameState.level / 2);
            
            for (let i = 0; i < numIslands; i++) {
                const island = {
                    x: 100 + Math.random() * (canvas.width - 200),
                    y: 120 + (i * 80) + Math.random() * 40,
                    width: 80,
                    height: 40,
                    safe: true
                };
                trafficIslands.push(island);
            }
        }

        // Initialize obstacles with 8 lanes
        function createObstacles() {
            obstacles = [];
            items = [];
            const lanes = 8;
            
            for (let i = 0; i < lanes; i++) {
                const lane = {
                    y: 80 + (i * 60),
                    obstacles: [],
                    items: [],
                    direction: i % 2 === 0 ? 1 : -1,
                    lastSpawn: 0,
                    lastItemSpawn: 0,
                    speed: 1 + (gameState.level * 0.2)
                };
                obstacles.push(lane);
            }
        }

        // Spawn obstacle in lane
        function spawnObstacle(laneIndex) {
            const lane = obstacles[laneIndex];
            const now = Date.now();
            
            // Spawn obstacles
            if (now - lane.lastSpawn > 1500 + Math.random() * 2500) {
                const hostileTypes = Object.keys(objectTypes).filter(key => objectTypes[key].hostile);
                const typeKey = hostileTypes[Math.floor(Math.random() * hostileTypes.length)];
                const objType = objectTypes[typeKey];
                
                const obstacle = {
                    x: lane.direction > 0 ? -objType.width : canvas.width + objType.width,
                    y: lane.y + Math.random() * 20,
                    width: objType.width,
                    height: objType.height,
                    speed: objType.speed * lane.speed,
                    direction: lane.direction,
                    damage: objType.damage,
                    ...objType
                };
                lane.obstacles.push(obstacle);
                lane.lastSpawn = now;
            }
            
            // Spawn friendly items occasionally
            if (now - lane.lastItemSpawn > 8000 + Math.random() * 5000) {
                const friendlyTypes = Object.keys(objectTypes).filter(key => objectTypes[key].friendly);
                const typeKey = friendlyTypes[Math.floor(Math.random() * friendlyTypes.length)];
                const itemType = objectTypes[typeKey];
                
                const item = {
                    x: lane.direction > 0 ? -itemType.width : canvas.width + itemType.width,
                    y: lane.y + Math.random() * 20,
                    width: itemType.width,
                    height: itemType.height,
                    speed: itemType.speed * lane.speed,
                    direction: lane.direction,
                    heal: itemType.heal,
                    ...itemType
                };
                lane.items.push(item);
                lane.lastItemSpawn = now;
            }
        }

        // Update obstacles and items
        function updateObstacles() {
            obstacles.forEach((lane, laneIndex) => {
                spawnObstacle(laneIndex);
                
                // Update obstacles
                lane.obstacles.forEach((obstacle, obsIndex) => {
                    obstacle.x += obstacle.speed * obstacle.direction;
                    if (obstacle.x < -150 || obstacle.x > canvas.width + 150) {
                        lane.obstacles.splice(obsIndex, 1);
                    }
                });
                
                // Update items
                lane.items.forEach((item, itemIndex) => {
                    item.x += item.speed * item.direction;
                    if (item.x < -150 || item.x > canvas.width + 150) {
                        lane.items.splice(itemIndex, 1);
                    }
                });
            });
        }

        // Check if player is on traffic island
        function isOnTrafficIsland() {
            return trafficIslands.some(island => 
                player.x < island.x + island.width &&
                player.x + player.width > island.x &&
                player.y < island.y + island.height &&
                player.y + player.height > island.y
            );
        }

        // Draw everything
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw road
            ctx.fillStyle = '#34495e';
            ctx.fillRect(0, 60, canvas.width, 560);
            
            // Draw lane lines
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 2;
            ctx.setLineDash([15, 15]);
            for (let i = 1; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 60 + (i * 60));
                ctx.lineTo(canvas.width, 60 + (i * 60));
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Draw sidewalks
            ctx.fillStyle = '#95a5a6';
            ctx.fillRect(0, 0, canvas.width, 60);
            ctx.fillRect(0, 620, canvas.width, 80);
            
            // Draw traffic islands
            trafficIslands.forEach(island => {
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(island.x, island.y, island.width, island.height);
                ctx.fillStyle = '#2c3e50';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üèùÔ∏è', island.x + island.width/2, island.y + island.height/2 + 7);
            });
            
            // Draw office building
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(canvas.width/2 - 60, 5, 120, 50);
            ctx.fillStyle = '#2c3e50';
            ctx.font = '35px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üè¢', canvas.width/2, 40);
            
            // Draw obstacles and items
            obstacles.forEach(lane => {
                lane.obstacles.forEach(obstacle => {
                    ctx.fillStyle = obstacle.color;
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(obstacle.symbol, obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2 + 6);
                });
                
                lane.items.forEach(item => {
                    ctx.fillStyle = item.color;
                    ctx.fillRect(item.x, item.y, item.width, item.height);
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(item.symbol, item.x + item.width/2, item.y + item.height/2 + 6);
                });
            });
            
            // Draw player (Nick)
            if (player.invulnerable > 0) {
                ctx.globalAlpha = Math.sin(Date.now() / 100) * 0.5 + 0.5;
            }
            
            ctx.fillStyle = isOnTrafficIsland() ? '#27ae60' : '#3498db';
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.font = '25px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üö∂‚Äç‚ôÇÔ∏è', player.x + player.width/2, player.y + player.height/2 + 8);
            
            ctx.globalAlpha = 1;
        }

        // Check collisions
        function checkCollisions() {
            if (player.invulnerable > 0 || isOnTrafficIsland()) {
                return;
            }
            
            obstacles.forEach(lane => {
                // Check obstacle collisions
                lane.obstacles.forEach((obstacle, obsIndex) => {
                    if (player.x < obstacle.x + obstacle.width &&
                        player.x + player.width > obstacle.x &&
                        player.y < obstacle.y + obstacle.height &&
                        player.y + player.height > obstacle.y) {
                        
                        playerHit(obstacle.damage);
                        lane.obstacles.splice(obsIndex, 1);
                    }
                });
                
                // Check item collisions
                lane.items.forEach((item, itemIndex) => {
                    if (player.x < item.x + item.width &&
                        player.x + player.width > item.x &&
                        player.y < item.y + item.height &&
                        player.y + item.height > item.y) {
                        
                        playerHeal(item.heal);
                        lane.items.splice(itemIndex, 1);
                    }
                });
            });
        }

        // Player hit
        function playerHit(damage) {
            gameState.hp -= damage;
            player.invulnerable = 120; // 2 seconds at 60fps
            gameState.score = Math.max(0, gameState.score - 10);
            
            updateDisplay();
            
            if (gameState.hp <= 0) {
                endGame("Nick's HP dropped to zero on the mean streets of the Yookay!");
            }
        }

        // Player heal
        function playerHeal(healAmount) {
            gameState.hp = Math.min(gameState.maxHp, gameState.hp + healAmount);
            gameState.score += 20;
            updateDisplay();
        }

        // Handle input
        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);

        // Update player
        function updatePlayer() {
            if (player.invulnerable > 0) player.invulnerable--;
            
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) player.x += player.speed;
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.height) player.y += player.speed;
        }

        // Check win condition
        function checkWin() {
            if (player.y <= 60) {
                const bonus = gameState.hp + (gameState.level * 50);
                gameState.score += bonus;
                
                document.getElementById('levelBonus').textContent = bonus;
                document.getElementById('levelComplete').style.display = 'block';
                gameState.paused = true;
            }
        }

        // Next street
        function nextStreet() {
            gameState.level++;
            gameState.currentStreet = (gameState.currentStreet + 1) % streets.length;
            
            if (gameState.level > 8) {
                endGame("Nick conquered all 8 Yookay streets! What a legend!");
                return;
            }
            
            player.x = canvas.width / 2;
            player.y = canvas.height - 50;
            
            createObstacles();
            createTrafficIslands();
            updateDisplay();
            
            document.getElementById('levelComplete').style.display = 'none';
            gameState.paused = false;
        }

        // Update display
        function updateDisplay() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('hp').textContent = gameState.hp;
            document.getElementById('streetName').textContent = streets[gameState.currentStreet];
            
            const hpDisplay = document.getElementById('hpDisplay');
            if (gameState.hp <= 30) {
                hpDisplay.classList.add('low');
            } else {
                hpDisplay.classList.remove('low');
            }
        }

        // End game
        function endGame(message) {
            gameState.gameOver = true;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Restart game
        function restartGame() {
            gameState = {
                score: 0,
                level: 1,
                hp: 100,
                maxHp: 100,
                gameOver: false,
                paused: false,
                currentStreet: 0
            };
            
            player.x = canvas.width / 2;
            player.y = canvas.height - 50;
            player.invulnerable = 0;
            
            createObstacles();
            createTrafficIslands();
            updateDisplay();
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('levelComplete').style.display = 'none';
        }

        // Main game loop
        function gameLoop() {
            if (!gameState.gameOver && !gameState.paused) {
                updatePlayer();
                updateObstacles();
                checkCollisions();
                checkWin();
            }
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // Initialize game
        createObstacles();
        createTrafficIslands();
        updateDisplay();
        gameLoop();
    </script>
</body>
</html>
